# Go GC : Priorisation à la faible latence et à la simplicité

31 Août 2015

## La mise en place

Go est en train de construire un ramasse miette (GC) non seulement pour 2015 mais pour 2025 et au-delà : un GC qui prend en charge les logiciels développés d'aujourd'hui et permettra de s'adapter sur les nouveaux logiciels et matériels des prochaines décennies. // Un tel avenir n'a pas de place pour des pauses qui arrêtent le runtime durant le passage du GC, qui a été un obstacle à des cas d'usage dans d'autres langages aussis sûrs et sécurisé que Go.

GO 1,5 est le premier aperçu de ce futur et réalise des latences du GC bien en deçà de l'objectif de 10 millisecondes que nous avions établi un an auparavant. Nous avons présenté des chiffres impressionnants à [la conférence à Gophercon](https://talks.golang.org/2015/go-gc.pdf). Les améliorations de latence ont généré beaucoup d'attention; Le blog de de ​​Robin Verlangen dans l'article [les milliards de requête](https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911) valide et rejoint nos efforts avec des résultats. Nous avons aussi particulièrement apprécié [les graphiques du serveur de production d'Alan Shreve](https://twitter.com/inconshreveable/status/620650786662555648) et son tweet « Sacré réduction de 85 % ".

Aujourd'hui, 16 gigaoctets de RAM coûtent 100$ et les processeurs sont livrés avec de nombreux cœurs, chacun avec plusieurs threads physiques. Dans une dizaine d'années ce matériel semblera vieillot, mais les logiciels en cours de construction en Go devront évoluer pour répondre aux besoins en expansion et aux prochaines grandes révolutions. Étant donné que le futur matériel supportera d'augmenter le débit, le ramasse miette de Go est déjà entrain d'être conçu pour favoriser une faible latence géré via une seule commande. Go 1.5 est la première grande étape engagée dans cette voie et ces premiers pas vont pour toujours influencer Go et permettre une meilleure adaptabilité des applications. Ce blog donne un aperçu de haut niveau de ce que nous avons fait pour le ramasse miette de Go 1.5.

## L'Embellissement

Pour créer un ramasse miette pour les prochaines décennies, nous nous sommes inspirés d'un algorithme créé il y a plusieurs décennies. Le ramasse miette de Go est concurrent, tricolor et a un marqueur de ramasseur. Cette idée avait été proposée par Dijkstra en 1978. Cette divergence est délibérée de la plupart des "projets" de ramasse miette de qualité d'aujourd'hui et nous croyons cette solutions plus adapté aux propriétés du matériel moderne et aux exigences de latence des logiciels modernes.

Dans un GC tricolore, chaque objet est soit blanc, gris ou noir et nous considérons la pile comme un graphe d'objets connectés. Au début d'un cycle de GC tous les objets sont blancs. Le GC visites toutes les racines, qui sont des objets directement accessibles par l'application tels que les variables globals et toutes les autres choses sur la pile et les coulris en gris. Le GC choisit alors un objet gris, le noircit, puis scanne pour ses pointeurs vers d'autres objets. Lorsque cette analyse trouve un pointeur vers un objet blanc, il se transforme cet objet gris. Ce processus se répète jusqu'à ce qu'il n'y ai plus d'objets gris. À ce stade, les objets blancs sont connus pour être inaccessible et peuvent être réutilisés.

Tous sela se passe en concurrence dans l'application, connu sous le nom de **mutateur**, changeant les pointeurs pendant que le ramasse miette est en marche. Par conséquent, le **mutateur** doit invariablement maintenir qu'aucuns objets noirs ne pointent vers des un objets blanc, de peur que le ramasse miette ne perde la trace d'un objet installé dans une partie de la pile qu'il a déjà visité. Le maintien de cet invariabilité est le travail de la barrière d'écriture, qui est une petite fonction gérée par le **mutateur** chaque fois qu'un pointeur dans la pile est modifié. La barrière d'écriture de Go coloris les objets gris accessible à l'instant si ils sont blanc, veillant aussi à ce que le ramasse miette finisse par scanner les pointeurs correspondants.

Décider quand la tâche doit trouver tous les objets gris quelle qu'en soit la subtilité mise en œuvre peut être coûteux et compliqué si nous voulons éviter de bloquer les mutateurs. Pour garder les choses simples Go 1.5 fait autant de travail qu'il peut en même temps, puis arrête brièvement l'application pour inspecter toutes les sources potentielles d'objets gris. Trouver le point d'équilibre entre le temps nécessaire pour cette dernière étape qui arrête l'application et le volume total des travaux qu'effectue le GC est un livrable majeur pour Go 1.6.

Bien sûr, le mieux est l'énnemi du bien. Quand allons-nous commencer un cycle de GC ? Quels paramètres utilisons-nous pour prendre cette décision ? Comment le GC devrait interagir avec l'orchestrateur de Go? Comment méttons nous en pause un fil de **mutateur** assez longtemps pour pouvoir scanner toute sa pile ? Comment pouvons-nous représenter le blanc, le gris et le noir pour que nous puissions trouver efficacement et analyser les objets gris ? Comment savoir où les racines sont ? Comment savons-nous où dans un objet pointeurs sont situés ? Comment minimiser la fragmentation de la mémoire ? Comment traitons-nous les problèmes de performances du cache ? Quelle devrait être la taille idéale de la pile ? Et ainsi de suite, certains liés à l'allocation, les unes pour trouver des objets accessibles, certaines liés à la planification, mais beaucoup sont liées à la performance. Ces discussions de bas niveau de chacun de ces domaines sont au-delà de la portée de ce blog.

À un niveau supérieur, une approche pour résoudre les problèmes de performance est d'ajouter des commandes de RM, un pour chaque problème de performance. Le programmeur peut alors jouer avec les commandes pour la recherche des paramètres appropriés pour leur application. L'inconvénient est qu'après une décennie avec une ou deux nouvelles commandes chaque année vous vous retrouvez avec La Charte d'Utilisation des Commandes du RM. Go ne va pas dans cette direction. Au lieu de cela, nous fournissons une seule commande, appelé **GOGC**. Cette valeur contrôle la taille totale de la pile par rapport à la taille des objets accessibles. La valeur par défaut de 100 ce qui signifie que la taille totale de la pile est de 100%, à savoir, deux fois plus grande que la taille des objets accessibles après la dernière collection. 200 signifie que la taille totale du tas est de 200% plus grande que la taille des objets accessibles. Si vous voulez réduire le temps total passé en RM, augmenter GOGC. Si vous voulez faire passer plus de temps sur le GC pour moins d'utilisation de mémoire, abaisser GOGC.


More importantly as RAM doubles with the next generation of hardware, simply doubling GOGC will halve the number of GC cycles. On the other hand since GOGC is based on reachable object size, doubling the load by doubling the reachable objects requires no retuning. The application just scales. Furthermore, unencumbered by ongoing support for dozens of knobs, the runtime team can focus on improving the runtime based on feedback from real customer applications.



Double Plus important que la RAM avec la prochaine génération de matériel, café Doubler OGC réduire de moitié kk le nombre de cycles de RM. D'autre part, depuis l' OGC est basée sur notre objet et intouchable, Doubler Doubler la charge par ledit objet intouchable et nécessite réaccorder. L'application des échelles juste. En outre , encombré par un soutien continu pour des dizaines de boutons, l'équipe d'exécution peut se concentrer sur la mesure de l'exécution sur la base des commentaires des applications clients réels.


## La Punchline

Go 1.5’s GC ushers in a future where stop-the-world pauses are no longer a barrier to moving to a safe and secure language. It is a future where applications scale effortlessly along with hardware and as hardware becomes more powerful the GC will not be an impediment to better, more scalable software. It’s a good place to be for the next decade and beyond. For more details about the 1.5 GC and how we eliminated latency issues see the Go GC: Latency Problem Solved presentation or the slides.


Les appariteur du GC de Go 1.5 dans un futur où les pauses qui arrêtent le runtime ne sont plus un obstacle pour passer à un langage sûr et sécurisé. Il est un avenir où les applications échelle sans effort ainsi que le matériel et que le matériel devient plus puissant que le GC ne sera pas un obstacle à de meilleurs logiciels, plus évolutifs. Il est un bon endroit pour être pour la prochaine décennie et au-delà. Pour plus de détails au sujet de la GC 1.5 et comment nous avons éliminé les problèmes de latence voir le Go GC : [Présentation problème Latence Résolu](https://www.youtube.com/watch?v=aiv1JOfMjm0) ou les [diapositives](https://talks.golang.org/2015/go-gc.pdf).


By Richard Hudson