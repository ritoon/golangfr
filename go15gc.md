# Go GC : Prioriser la faible latence et la simplicité

31 Août 2015

## La mise en place

Go est en train de construire un ramasse-miettes (GC) non seulement pour 2015 mais pour 2025 et au-delà : un GC qui prend en charge le développement des logiciels contemporains et permettra de s'adapter sur les nouveaux logiciels et matériels des dix prochaines années. Un tel avenir ne pourra tolérer les pauses de GC et leur arrêt de runtime, qui ont été un obstacle à des cas d'usage dans d'autres langages aussi sûrs et sécurisés que Go.

Go 1.5, le premier aperçu de ce futur, réalise des latences de GC bien en deçà de l'objectif de 10 milli-secondes que nous avions établi un an auparavant. Nous avons présenté des chiffres impressionnants lors de [la conférence de Gophercon](https://talks.golang.org/2015/go-gc.pdf). Les améliorations de latence ont généré beaucoup d’attention ; l’article du blog de ​​Robin Verlangen, [les milliards de requête](https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911) rejoint notre point de vue avec des résultats en conséquence. Nous avons aussi particulièrement apprécié [le graphique du serveur de production d'Alan Shreve](https://twitter.com/inconshreveable/status/620650786662555648) et son commentaire : « 85 % , une sacrée réduction ! ".

Aujourd’hui, 16 giga-octets de RAM coûtent 100$ et les processeurs sont livrés avec de nombreux cœurs, chacun avec de multiples threads physiques. Dans une dizaine d’années, ce matériel semblera vieillot, mais les logiciels aujourd’hui construits en Go devront évoluer pour répondre aux besoins en expansion et aux autres prochaines grandes révolutions. En considérant que le futur matériel aura la puissance nécessaire pour augmenter le débit, le ramasse-miettes de Go sera tout désigné pour favoriser une faible latence gérée via une seule commande. Go 1.5 est une première grande étape engagée dans cette voie, et ces premiers pas auront une influence considérable pour Go et pour les applications qui le gèrent au mieux. Cet article offre un très bon aperçu de ce que nous avons fait pour le ramasse-miettes de Go 1.5.

## L'Embellissement

Afin de créer un ramasse-miettes viable pour les dix prochaines années, nous nous sommes inspirés d'un algorithme créé il y a plusieurs décennies. Le nouveau ramasse-miettes de Go est concurrent, tricolore et dispose d’un marqueur de ramasseur. Cette idée avait été proposée par Dijkstra en 1978. Ce choix est délibérément divergent de la plupart des projets « professionnels » et « qualitatifs » de ramasse-miettes d’aujourd'hui, idée que nous pensons plus adaptée aux propriétés du matériel moderne et aux exigences de latence des logiciels modernes.

Dans un GC tricolore, chaque objet est soit blanc, gris ou noir, et nous considérons la pile comme un graphe d'objets connectés. Au début d'un cycle de GC, tous les objets sont blancs. Le GC visite toutes les racines, qui sont des objets directement accessibles par l'application tels que les variables globales et toutes les autres choses sur la pile, et les colore en gris. Le GC choisit alors un objet gris, le noircit, puis le scanne pour ses pointeurs dirigés vers d'autres objets. Lorsque cette analyse trouve un pointeur vers un objet blanc, il passe cet objet en gris. Ce processus se répète jusqu'à ce qu'il n'y ait plus d'objets gris. À ce stade, les objets blancs sont connus pour être inaccessibles et peuvent être réutilisés.

Tout cela se passe en concurrence avec l'application, connue sous le nom de **mutateur**, changeant les pointeurs pendant que le ramasse-miettes est en marche. Par conséquent, le **mutateur** doit invariablement maintenir qu'aucun objet noir ne pointe vers un objet blanc, de peur que le ramasse-miettes ne perde la trace d'un objet installé dans une partie de la pile qu'il a déjà visité. Le maintien de cette invariabilité est le travail de la **barrière d’écriture**, qui est une petite fonction lancée par le mutateur dès qu'un pointeur est modifié dans la pile. La barrière d'écriture de Go colore en gris les objets accessibles à l'instant si ils sont blanc, veillant aussi à ce que le ramasse-miettes finisse par scanner les pointeurs correspondants.

Décider quand la tâche qui consiste à trouver tous les objets gris est terminée est une décision subtile et qui peut être coûteuse et complexe si nous voulons éviter de bloquer les mutateurs. Pour faire simple, Go 1.5 fait autant de travail qu'il le peut en même temps, puis arrête brièvement l'application pour inspecter toutes les sources potentielles d'objets gris. Trouver le point d'équilibre entre le temps nécessaire pour cette dernière étape qui arrête l'application et le volume total des travaux qu'effectue le GC est un livrable majeur pour Go 1.6.

Bien sûr, le mieux est l'ennemi du bien. Quand devons-nous commencer un cycle de GC ? Quels paramètres utilisons-nous pour prendre cette décision ? Comment le GC doit-il interagir avec l'orchestrateur de Go? Comment mettons-nous en pause un fil de mutateur assez longtemps pour pouvoir scanner toute sa pile ? Comment pouvons-nous représenter le blanc, le gris et le noir pour que nous puissions efficacement trouver et analyser les objets gris ? Comment savoir où les racines se trouvent ? Comment pouvons-nous savoir où se situent les pointeurs d’un objet ? Comment minimiser la fragmentation de la mémoire ? Comment traitons-nous les problèmes de performances du cache ? Quelle devrait être la taille idéale de la pile ? Qu’il s’agisse de l'allocation, de trouver des objets accessibles, de la planification, le principal sujet reste la performance. Les discussions secondaires autour de chacun de ces domaines sont au-delà de la portée de cet article.

À un niveau supérieur, une approche possible pour résoudre les problèmes de performance est d'ajouter des commandes de GC, une pour chaque problème de performance. Le programmeur peut alors jouer avec les commandes pour rechercher des paramètres appropriés à leur application. L'inconvénient est qu'après une décennie avec une ou deux nouvelles commandes par an, vous vous retrouverez avec la Charte d'Utilisation des Commandes du GC. Go ne va pas dans cette direction. À la place, nous proposons une seule commande, appelé **GOGC**. Cette valeur contrôle la taille totale de la pile par rapport à la taille des objets accessibles. La valeur par défaut de 100 signifie que la taille totale de la pile est de 100%, à savoir, deux fois plus grande que la taille des objets accessibles après la dernière collection. 200 signifie que la taille totale du tas est 200% plus grande que la taille des objets accessibles. Si vous voulez réduire le temps total passé en GC, augmentez GOGC. Si vous voulez échanger plus de temps de GC pour moins d'utilisation de mémoire, diminuez GOGC.


Encore plus important, étant donné que la RAM sera doublée avec la nouvelle génération de matériel, le fait de doubler GOGC divisera par deux le nombres de cycles de GC. D’un autre côté, depuis que GOGC est basé sur la taille d’un objet accessible, doubler le chargement en doublant les objets accessibles ne nécessite pas de retour. L’application se met juste à l’échelle. En outre, n’étant plus encombrée par le support continu à apporter à des dizaines et des dizaines de commandes, l’équipe d’exécution peut se concentrer pour optimiser le temps d’exécution basé sur les retours d’applications de clients réels.


## La Punchline


Le ramasse-miettes de Go 1.5 s’introduit dans un avenir ou les pauses de runtime n’empêcheront plus l’utilisation de langages fiables et sécurisés tel que Go. Dans ce futur, où les applications s’adapteront sans effort aux matériels, et où ces matériels deviendront de plus en plus puissants, le GC ne sera plus un obstacle à des applications meilleures, mieux adaptables et plus évolutives. La prochaine décennie s’annonce donc bien. Pour plus de détails au sujet de la GC 1.5 et de comment nous avons éliminé les problèmes de latence, voir le Go GC : [Présentation problème Latence Résolu](https://www.youtube.com/watch?v=aiv1JOfMjm0) ou les [diapositives](https://talks.golang.org/2015/go-gc.pdf).




By Richard Hudson

Traduit le 02 Août 2016 par Henri Lepic à partir du [Blog Golang.org](https://blog.golang.org/go15gc).
